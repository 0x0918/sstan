
 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 1 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> floating_pragma.sol 3-3 
 ```solidity 
 pragma solidity ^0.8.16; 
 ``` 
 </details>

 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 2 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> incorrect_shift_math.sol 6-7 
 ```solidity 
 shl(x, 1) 
 ```
 &nbsp;
 <span style="color: green;">File: </span> incorrect_shift_math.sol 7-8 
 ```solidity 
 shr(x, 1) 
 ``` 
 </details>

 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 2 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> uninitialized_storage_variable.sol 6-6 
 ```solidity 
 address owner3; 
 ```
 &nbsp;
 <span style="color: green;">File: </span> uninitialized_storage_variable.sol 5-5 
 ```solidity 
 address owner2; 
 ``` 
 </details>

 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 3 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> unsafe_erc20_operation.sol 11-11 
 ```solidity 
 e.approve 
 ```
 &nbsp;
 <span style="color: green;">File: </span> unsafe_erc20_operation.sol 12-12 
 ```solidity 
 e.transfer 
 ```
 &nbsp;
 <span style="color: green;">File: </span> unsafe_erc20_operation.sol 13-13 
 ```solidity 
 e.transferFrom 
 ``` 
 </details>

 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 2 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> unprotected_self_destruct.sol 6-6 
 ```solidity 
 function unprotectedKill() public {selfdestruct(msg.sender)} 
 ```
 &nbsp;
 <span style="color: green;">File: </span> unprotected_self_destruct.sol 11-11 
 ```solidity 
 function unprotectedKill2() external {suicide(owner)} 
 ``` 
 </details>

 <details open> 
 <summary> 
 <h1> Division before multiplication - Instances: 22 </h1>
 </summary> 
 &nbsp; 
        Consider ordering multiplication before division to avoid loss of precision because integer division might truncate. Loss of precision in Solidity can lead to vulnerabilities because it can result in unexpected behavior in smart contracts. This can be particularly problematic in financial applications, where even small errors in calculations can have significant consequences. For example, if a contract uses integer division to calculate a result and the division operation truncates the fractional part of the result, it could lead to incorrect pricing or loss of funds due to miscalculated balances.

        #### Unsafe Division
        ```js
        n = 5 / 2 * 4; // n = 8 because 5 / 2 == 2 since division truncates.
        ```
        #### Safe Division
        ```js
        n = 5 * 4 / 2; // n = 10
        ```
         

 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 29-29 
 ```solidity 
 x /= 2 * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 31-31 
 ```solidity 
 x /= (2 * 3) 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 32-32 
 ```solidity 
 x /= (1 / 2) * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 33-33 
 ```solidity 
 x /= (1 * 2) * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 34-34 
 ```solidity 
 x /= (2 * 3) / 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 35-35 
 ```solidity 
 x /= 2 * 3 / 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 36-36 
 ```solidity 
 x /= 2 * 3 - 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 37-37 
 ```solidity 
 x /= 2 * 3 % 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 38-38 
 ```solidity 
 x /= 2 * 3 | 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 39-39 
 ```solidity 
 x /= 2 * 3 & 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 40-40 
 ```solidity 
 x /= 2 * 3 ^ 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 41-41 
 ```solidity 
 x /= 2 * 3 << 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 42-42 
 ```solidity 
 x /= 2 * 3 >> 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 6-6 
 ```solidity 
 1 / 2 * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 8-8 
 ```solidity 
 (1 / 2) * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 10-10 
 ```solidity 
 (1 / 2 * 3) * 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 10-10 
 ```solidity 
 1 / 2 * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 11-11 
 ```solidity 
 (1 * 2 / 3) * 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 12-12 
 ```solidity 
 (1 / 2 / 3) * 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 13-13 
 ```solidity 
 1 / (2 + 3) * 4 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 25-25 
 ```solidity 
 (2 / 3) * 3 
 ```
 &nbsp;
 <span style="color: green;">File: </span> divide_before_multiply.sol 32-32 
 ```solidity 
 (1 / 2) * 3 
 ``` 
 </details>
