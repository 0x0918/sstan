pub mod divide_before_multiply;
pub mod floating_pragma;
pub mod incorrect_shift_math;
pub mod uninitialized_storage_variable;
pub mod unprotected_self_destruct;
pub mod unsafe_erc20_operation;

use super::engine::Outcome;
use crate::engine::EngineError;
use crate::report::{Classification, OutcomeReport, ReportSectionFragment};
use crate::utils;
use solang_parser::pt::{Loc, SourceUnit};
use std::collections::HashMap;
use std::path::PathBuf;

pub trait VulnerabilityPattern {
    fn find(source: &mut HashMap<PathBuf, SourceUnit>)
        -> Result<VulnerabilityOutcome, EngineError>;
}

#[macro_export]
macro_rules! vulnerability {
    ($(($name:ident, $report_title:expr, $description:expr, $classification:expr)),+ $(,)?) => {


        $(pub struct $name;)+

        #[allow(non_snake_case)]
        #[derive(Debug)]
        pub enum VulnerabilityTarget {
            $($name,)+
        }


        impl VulnerabilityTarget{
            pub fn find(
                &self,
                source: &mut HashMap<PathBuf, SourceUnit>,
            ) -> Result<VulnerabilityOutcome, EngineError> {
                match self {
                    $(
                        VulnerabilityTarget::$name => $name::find(source),
                    )+
                }

            }

        }


        #[derive(Debug)]
        pub enum VulnerabilityOutcome {
            $($name(Outcome),)+
        }


        impl VulnerabilityOutcome {
            pub fn len(&self) -> usize {
                match self {
                    $(
                        VulnerabilityOutcome::$name(outcome) => outcome.iter().map(|(_, v)| v.len()).sum(),
                    )+
                }
            }

            pub fn is_empty(&self) -> bool {
                self.len() == 0
            }

            pub fn classification(&self) -> Classification {
                match self {
                    $(
                        VulnerabilityOutcome::$name(_) => $classification,
                    )+
                }
            }
        }




        impl From<VulnerabilityOutcome> for Option<ReportSectionFragment> {
            fn from(value: VulnerabilityOutcome) -> Self {
                match value {
                    $(
                        VulnerabilityOutcome::$name(outcome) => {
                            if outcome.is_empty() {
                                return None;
                            }
                            let length = outcome.iter().map(|(_, v)| v.len()).sum::<usize>();


                            let mut report_fragment = ReportSectionFragment::new(
                                $report_title.to_string(),
                                None,
                                $description.to_string(),
                                length,
                            );
                            let mut outcome_reports = vec![];
                            for (path, loc_snippets) in outcome.iter() {
                                let file_name = path.file_name().expect("couldnt get file name")  //TODO: make this a little more descriptive or propagate
                                .to_str()
                                .expect("no filename"); //TODO: make this a little more descriptive or propagate

                                for (loc, snippet) in loc_snippets.iter() {
                                    if let Loc::File(_, start, end) = loc{
                                        let file_contents = std::fs::read_to_string(path).expect("couldnt read file"); //TODO: propagate this or maybe just make more descriptive
                                        let start_line = utils::get_line_number(*start, &file_contents);
                                        let end_line = utils::get_line_number(*end, &file_contents);
                                        outcome_reports.push(OutcomeReport::new(
                                            file_name.to_string(),
                                            (start_line, end_line),
                                            snippet.to_string(),
                                        ));

                                }else{
                                    panic!("handle this TODO:");

                                }
                            }


                            }
                            report_fragment.outcomes = outcome_reports;
                            Some(report_fragment)

                        }



                    )+

                }

            }
        }




        //TODO: into tablefragment, propagate an eror if identifier nonce is not populated?





    };



}

//TODO: in the future maybe make this generated by gpt4
//TODO: adjust these classifications
vulnerability!(
    (
        DivideBeforeMultiply,
        "Order multiplication before division to avoid loss of precision",
        "description goes here",
        Classification::VulnerabilityMedium
    ),
    (
        IncorrectShiftMath, // TODO: we should change this to be more descriptive since its only in assembly blocks, something like IncorrectShiftOperation
        "title goes here",
        "description goes here",
        Classification::VulnerabilityMedium
    ),
    (
        FloatingPragma,
        "title goes here",
        "description goes here",
        Classification::VulnerabilityLow
    ),
    (
        UninitializedStorageVariable,
        "title goes here",
        "description goes here",
        Classification::VulnerabilityHigh
    ),
    (
        UnprotectedSelfDestruct,
        "title goes here",
        "description goes here",
        Classification::VulnerabilityHigh
    ),
    (
        UnsafeErc20Operation,
        "title goes here",
        "description goes here",
        Classification::VulnerabilityLow
    )
);
